#!/usr/bin/env ruby

# Arvados cli client
#
# Ward Vandewege <ward@clinicalfuture.com>

require 'fileutils'

if RUBY_VERSION < '1.9.3' then
  abort <<-EOS
#{$0.gsub(/^\.\//,'')} requires Ruby version 1.9.3 or higher.
  EOS
end

begin
  require 'curb'
  require 'rubygems'
  require 'google/api_client'
  require 'json'
  require 'pp'
  require 'trollop'
  require 'andand'
  require 'oj'
  require 'active_support/inflector'
  require 'yaml'
rescue LoadError
  abort <<-EOS

Please install all required gems:

  gem install activesupport andand curb google-api-client json oj trollop yaml

  EOS
end

# Search for 'ENTRY POINT' to see where things get going

ActiveSupport::Inflector.inflections do |inflect|
  inflect.irregular 'specimen', 'specimens'
  inflect.irregular 'human', 'humans'
end

module Kernel
  def suppress_warnings
    original_verbosity = $VERBOSE
    $VERBOSE = nil
    result = yield
    $VERBOSE = original_verbosity
    return result
  end
end

class Google::APIClient
 def discovery_document(api, version)
   api = api.to_s
   return @discovery_documents["#{api}:#{version}"] ||=
     begin
       # fetch new API discovery doc if stale
       cached_doc = File.expand_path '~/.cache/arvados/discovery_uri.json'
       if not File.exist?(cached_doc) or (Time.now - File.mtime(cached_doc)) > 86400
         response = self.execute!(:http_method => :get,
                                  :uri => self.discovery_uri(api, version),
                                  :authenticated => false)
         FileUtils.makedirs(File.dirname cached_doc)
         File.open(cached_doc, 'w') do |f|
           f.puts response.body
         end
       end

       File.open(cached_doc) { |f| JSON.load f }
     end
 end
end

class ArvadosClient < Google::APIClient
  def execute(*args)
    if args.last.is_a? Hash
      args.last[:headers] ||= {}
      args.last[:headers]['Accept'] ||= 'application/json'
    end
    super(*args)
  end
end

def init_config
  # read authentication data from arvados configuration file if present
  lineno = 0
  config_file = File.expand_path('~/.config/arvados/settings.conf')
  if File.exist? config_file then
    File.open(config_file, 'r').each do |line|
      lineno = lineno + 1
      # skip comments
      if line.match('^\s*#') then
        next
      end
      var, val = line.chomp.split('=', 2)
      # allow environment settings to override config files.
      if var and val
        ENV[var] ||= val
      else
        warn "#{config_file}: #{lineno}: could not parse `#{line}'"
      end
    end
  end
end

subcommands = %w(keep pipeline tag ws edit)

def check_subcommands client, arvados, subcommand, global_opts, remaining_opts
  case subcommand
  when 'keep'
    @sub = remaining_opts.shift
    if ['get', 'put', 'ls', 'normalize'].index @sub then
      # Native Arvados
      exec `which arv-#{@sub}`.strip, *remaining_opts
    elsif ['less', 'check'].index @sub then
      # wh* shims
      exec `which wh#{@sub}`.strip, *remaining_opts
    elsif @sub == 'docker'
      exec `which arv-keepdocker`.strip, *remaining_opts
    else
      puts "Usage: arv keep [method] [--parameters]\n"
      puts "Use 'arv keep [method] --help' to get more information about specific methods.\n\n"
      puts "Available methods: ls, get, put, less, check, docker"
    end
    abort
  when 'pipeline'
    exec `which arv-run-pipeline-instance`.strip, *remaining_opts
  when 'tag'
    exec `which arv-tag`.strip, *remaining_opts
  when 'ws'
    exec `which arv-ws`.strip, *remaining_opts
  when 'edit'
    arv_edit client, arvados, global_opts, remaining_opts
  end
end

def arv_edit client, arvados, global_opts, remaining_opts
  n = remaining_opts.shift
  if n.nil? or n == "-h" or n == "--help"
    puts head_banner
    puts "Usage: arv edit [uuid] [fields...]\n\n"
    puts "Fetchs the specified Arvados object, select the specified fields, and\n"
    puts "open an interactive text editor on a text representation (json or\n"
    puts "yaml, use --format) and then updates the object.  Will use 'nano'\n"
    puts "by default, customize with the EDITOR or VISUAL environment variable.\n"
    exit 255
  end

  if not $stdout.tty?
    puts "Not connected to a TTY, cannot run interactive editor."
    exit 1
  end

  # determine controller

  m = /([a-z0-9]{5})-([a-z0-9]{5})-([a-z0-9]{15})/.match n
  if !m
    abort puts "#{n} does not appear to be an arvados uuid"
  end

  rsc = nil
  arvados.discovery_document["resources"].each do |k,v|
    klass = k.singularize.camelize
    dig = Digest::MD5.hexdigest(klass).to_i(16).to_s(36)[-5..-1]
    if dig == m[2]
      rsc = k
    end
  end

  if rsc.nil?
    abort "Could not determine resource type #{m[2]}"
  end

  api_method = 'arvados.' + rsc + '.get'

  result = client.execute(:api_method => eval(api_method),
                          :parameters => {"uuid" => n},
                          :authenticated => false,
                          :headers => {
                            authorization: 'OAuth2 '+ENV['ARVADOS_API_TOKEN']
                          })
  begin
    results = JSON.parse result.body
  rescue JSON::ParserError => e
    abort "Failed to parse server response:\n" + e.to_s
  end

  if remaining_opts.length > 0
    results.select! { |k, v| remaining_opts.include? k }
  end

  content = ""

  case global_opts[:format]
  when 'json'
    content = Oj.dump(results, :indent => 1)
  when 'yaml'
    content = results.to_yaml
  end

  require 'tempfile'

  tmp = Tempfile.new(n)
  tmp.write(content)
  tmp.close

  pid = Process::fork
  if pid.nil?
    editor ||= ENV["VISUAL"]
    editor ||= ENV["EDITOR"]
    editor ||= "nano"
    exec editor, tmp.path
  else
    Process.wait pid
  end

  if $?.exitstatus == 0
    tmp.open
    newcontent = tmp.read()

    newobj = {}
    case global_opts[:format]
    when 'json'
      newobj = Oj.load(newcontent)
    when 'yaml'
      newobj = YAML.load(newcontent)
    end
    tmp.close
    tmp.unlink

    if newobj != results
      api_method = 'arvados.' + rsc + '.update'
      result = client.execute(:api_method => eval(api_method),
                              :parameters => {"uuid" => n, rsc.singularize => Oj.dump(newobj)},
                              :authenticated => false,
                              :headers => {
                                authorization: 'OAuth2 '+ENV['ARVADOS_API_TOKEN']
                              })

      begin
        results = JSON.parse result.body
      rescue JSON::ParserError => e
        abort "Failed to parse server response:\n" + e.to_s
      end

      if result.response.status != 200
        puts "Update failed.  Server responded #{result.response.status}: #{results['errors']} "
      end
    else
      puts "Object is unchanged, did not update."
    end
  end

  exit 0
end

def to_boolean(s)
  !!(s =~ /^(true|t|yes|y|1)$/i)
end

def head_banner
  "Arvados command line client\n"
end

def help_methods(discovery_document, resource, method=nil)
  banner = head_banner
  banner += "Usage: arv #{resource} [method] [--parameters]\n"
  banner += "Use 'arv #{resource} [method] --help' to get more information about specific methods.\n\n"
  banner += "The #{resource} resource supports the following methods:"
  banner += "\n\n"
  discovery_document["resources"][resource.pluralize]["methods"].
    each do |k,v|
    description = ''
    if v.include? "description"
      # add only the first line of the discovery doc description
      description = '  ' + v["description"].split("\n").first.chomp
    end
    banner += "   #{sprintf("%20s",k)}#{description}\n"
  end
  banner += "\n"
  STDERR.puts banner

  if not method.nil? and method != '--help' and method != '-h' then
    abort "Unknown method #{method.inspect} " +
                  "for resource #{resource.inspect}"
  end
  exit 255
end

def help_resources(option_parser, discovery_document, resource)
  option_parser.educate

  if not resource.nil? and resource != '--help' then
    Trollop::die "Unknown resource type #{resource.inspect}"
  end
  exit 255
end

def parse_arguments(discovery_document, subcommands)
  resource_types = Array.new()
  discovery_document["resources"].each do |k,v|
    resource_types << k.singularize
  end

  resource_types += subcommands

  option_parser = Trollop::Parser.new do
    version __FILE__
    banner head_banner
    banner "Usage: arv [--flags] subcommand|resource [method] [--parameters]"
    banner ""
    banner "Available flags:"

    opt :dry_run, "Don't actually do anything", :short => "-n"
    opt :verbose, "Print some things on stderr"
    opt :format,
        "Set the output format. Must be one of json (default), yaml or uuid.",
        :type => :string,
        :default => 'json'
    opt :short, "Return only UUIDs (equivalent to --format=uuid)"

    banner ""
    banner "Use 'arv subcommand|resource --help' to get more information about a particular command or resource."
    banner ""
    banner "Available subcommands: #{subcommands.join(', ')}"
    banner ""

    banner "Available resources: #{discovery_document['resources'].keys.map { |k| k.singularize }.join(', ')}"

    banner ""
    banner "Additional options:"

    conflicts :short, :format
    stop_on resource_types
  end

  global_opts = Trollop::with_standard_exception_handling option_parser do
    o = option_parser.parse ARGV
  end

  unless %w(json yaml uuid).include?(global_opts[:format])
    $stderr.puts "#{$0}: --format must be one of json, yaml or uuid."
    $stderr.puts "Use #{$0} --help for more information."
    abort
  end

  if global_opts[:short]
    global_opts[:format] = 'uuid'
  end

  resource = ARGV.shift

  if not subcommands.include? resource
    if global_opts[:resources] or not resource_types.include?(resource)
      help_resources(option_parser, discovery_document, resource)
    end

    method = ARGV.shift
    if not (discovery_document["resources"][resource.pluralize]["methods"].
            include?(method))
      help_methods(discovery_document, resource, method)
    end

    discovered_params = discovery_document\
    ["resources"][resource.pluralize]\
    ["methods"][method]["parameters"]
    method_opts = Trollop::options do
      banner head_banner
      banner "Usage: arv #{resource} #{method} [--parameters]"
      banner ""
      banner "This method supports the following parameters:"
      banner ""
      discovered_params.each do |k,v|
        opts = Hash.new()
        opts[:type] = v["type"].to_sym if v.include?("type")
        if [:datetime, :text, :object, :array].index opts[:type]
          opts[:type] = :string                       # else trollop bork
        end
        opts[:default] = v["default"] if v.include?("default")
        opts[:default] = v["default"].to_i if opts[:type] == :integer
        opts[:default] = to_boolean(v["default"]) if opts[:type] == :boolean
        opts[:required] = true if v.include?("required") and v["required"]
        description = ''
        description = '  ' + v["description"] if v.include?("description")
        opt k.to_sym, description, opts
      end

      body_object = discovery_document["resources"][resource.pluralize]["methods"][method]["request"]
      if body_object and discovered_params[resource].nil?
        is_required = true
        if body_object["required"] == false
          is_required = false
        end
        opt resource.to_sym, "#{resource} (request body)", {
          required: is_required,
          type: :string
        }
      end
    end

    discovered_params.each do |k,v|
      k = k.to_sym
      if ['object', 'array'].index(v["type"]) and method_opts.has_key? k
        if method_opts[k].andand.match /^\//
          method_opts[k] = File.open method_opts[k], 'rb' do |f| f.read end
        end
      end
    end
  end

  return resource, method, method_opts, global_opts, ARGV
end

#
# ENTRY POINT
#

init_config

ENV['ARVADOS_API_VERSION'] ||= 'v1'

if not ENV.include?('ARVADOS_API_HOST') or not ENV.include?('ARVADOS_API_TOKEN') then
  abort <<-EOS
ARVADOS_API_HOST and ARVADOS_API_TOKEN need to be defined as environment variables.
  EOS
end

# do this if you're testing with a dev server and you don't care about SSL certificate checks:
if ENV['ARVADOS_API_HOST_INSECURE']
  suppress_warnings { OpenSSL::SSL::VERIFY_PEER = OpenSSL::SSL::VERIFY_NONE }
end

begin
  client = ArvadosClient.new(:host => ENV['ARVADOS_API_HOST'], :application_name => 'arvados-cli', :application_version => '1.0')
  arvados = client.discovered_api('arvados', ENV['ARVADOS_API_VERSION'])
rescue Exception => e
  puts "Failed to connect to Arvados API server: #{e}"
  exit 1
end

# Parse arguments here
resource_schema, method, method_opts, global_opts, remaining_opts = parse_arguments(arvados.discovery_document, subcommands)

check_subcommands client, arvados, resource_schema, global_opts, remaining_opts

controller = resource_schema.pluralize

api_method = 'arvados.' + controller + '.' + method

if global_opts[:dry_run]
  if global_opts[:verbose]
    $stderr.puts "#{api_method} #{method_opts.inspect}"
  end
  exit
end

request_parameters = {_profile:true}.merge(method_opts)
resource_body = request_parameters.delete(resource_schema.to_sym)
if resource_body
  request_body = {
    resource_schema => resource_body
  }
else
  request_body = nil
end

case api_method
when
  'arvados.jobs.log_tail_follow'

  # Special case for methods that respond with data streams rather
  # than JSON (TODO: use the discovery document instead of a static
  # list of methods)
  uri_s = eval(api_method).generate_uri(request_parameters)
  Curl::Easy.perform(uri_s) do |curl|
    curl.headers['Accept'] = 'text/plain'
    curl.headers['Authorization'] = "OAuth2 #{ENV['ARVADOS_API_TOKEN']}"
    if ENV['ARVADOS_API_HOST_INSECURE']
      curl.ssl_verify_peer = false
      curl.ssl_verify_host = false
    end
    if global_opts[:verbose]
      curl.on_header { |data| $stderr.write data }
    end
    curl.on_body { |data| $stdout.write data }
  end
  exit 0
else
  result = client.execute(:api_method => eval(api_method),
                          :parameters => request_parameters,
                          :body => request_body,
                          :authenticated => false,
                          :headers => {
                            authorization: 'OAuth2 '+ENV['ARVADOS_API_TOKEN']
                          })
end

begin
  results = JSON.parse result.body
rescue JSON::ParserError => e
  abort "Failed to parse server response:\n" + e.to_s
end

if results["errors"] then
  abort "Error: #{results["errors"][0]}"
end

case global_opts[:format]
when 'json'
  puts Oj.dump(results, :indent => 1)
when 'yaml'
  puts results.to_yaml
else
  if results["items"] and results["kind"].match /list$/i
    results['items'].each do |i| puts i['uuid'] end
  elsif results['uuid'].nil?
    abort("Response did not include a uuid:\n" +
          Oj.dump(results, :indent => 1) +
          "\n")
  else
    puts results['uuid']
  end
end
