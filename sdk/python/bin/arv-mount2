#!/usr/bin/env python

import os
import sys

import llfuse
import errno
import stat
import threading
import arvados
import argparse
import pprint

from time import time
from llfuse import FUSEError

class Directory(object):
    def __init__(self, inode, parent):
        self.inode = inode
        self.parent = parent
        self.entries = {}

    def __getitem__(self, item):
        return self.entries[item]

    def __setitem__(self, key, item):
        self.entries[key] = item

    def __iter__(self):
        return self.entries.iterkeys()

    def __contains__(self, k):
        return k in self.entries

    def size(self):
        return 0

class File(object):
    def __init__(self, inode, parent, reader):
        self.inode = inode
        self.parent = parent
        self.reader = reader

    def size(self):
        return self.reader.size()

class FileHandle(object):
    def __init__(self, fh, entry):
        self.fh = fh
        self.entry = entry

class Operations(llfuse.Operations):

    def __init__(self, collection, uid, gid):
        super(Operations, self).__init__()
        #self.api = arvados.api('v1')

        # dict of inodes to collection entry
        self._inodes = {}

        self.uid = uid
        self.gid = gid
        
        #print "root_parent", root_parent, "llfuse.ROOT_INODE", llfuse.ROOT_INODE

        i = llfuse.ROOT_INODE
        self.root = Directory(i, i)
        self._inodes[i] = self.root

        for s in collection.all_streams():
            cwd = self.root
            for part in s.name().split('/'):
                if part != '' and part != '.':
                    if part not in cwd:
                        i += 1
                        cwd[part] = Directory(i, cwd.inode)
                        self._inodes[i] = cwd[part]
                    cwd = cwd[part]
            for k, v in s.files().items():
                i += 1
                cwd[k] = File(i, cwd.inode, v)
                self._inodes[i] = cwd[k]

        # dict of inode to filehandle
        self._filehandles = {}
        self._filehandles_counter = 1

    def access(self, inode, mode, ctx):
        return True
   
    def getattr(self, inode):
        e = self._inodes[inode]

        entry = llfuse.EntryAttributes()
        entry.st_ino = inode
        entry.generation = 0
        entry.entry_timeout = 300
        entry.attr_timeout = 300

        entry.st_mode = stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH
        if isinstance(e, Directory):
            entry.st_mode |= stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH | stat.S_IFDIR
        else:
            entry.st_mode |= stat.S_IFREG

        entry.st_nlink = 1
        entry.st_uid = self.uid
        entry.st_gid = self.gid
        entry.st_rdev = 0

        entry.st_size = e.size()

        entry.st_blksize = 1024
        entry.st_blocks = e.size()/1024
        if e.size()/1024 != 0:
            entry.st_blocks += 1
        entry.st_atime = 0
        entry.st_mtime = 0
        entry.st_ctime = 0

        return entry

    def lookup(self, parent_inode, name):
        #print "lookup: parent_inode", parent_inode, "name", name
        inode = None

        if name == '.':
            inode = parent_inode
        else:
            if parent_inode in self._inodes:
                p = self._inodes[parent_inode]
                if name == '..':
                    inode = p.parent
                elif name in p:
                    inode = p[name].inode

        if inode != None:
            return self.getattr(inode)
        else:
            raise llfuse.FUSEError(errno.ENOENT)
   
    def open(self, inode, flags):
        if inode in self._inodes:
            p = self._inodes[inode]
        else:
            raise llfuse.FUSEError(errno.ENOENT)

        if isinstance(p, Directory):
            raise llfuse.FUSEError(errno.EISDIR)

        fh = self._filehandles_counter
        self._filehandles_counter += 1
        self._filehandles[fh] = FileHandle(fh, p)
        return fh

    def read(self, fh, off, size):
        #print "read", fh, off, size
        if fh in self._filehandles:
            handle = self._filehandles[fh]
        else:
            raise llfuse.FUSEError(errno.EBADF)

        try:
            with llfuse.lock_released:
                return handle.entry.reader.readfrom(off, size)
        except:
            raise llfuse.FUSEError(errno.EIO)

    def release(self, fh):
        if fh in self._filehandles:
            del self._filehandles[fh]

    def opendir(self, inode):
        #print "opendir: inode", inode

        if inode in self._inodes:
            p = self._inodes[inode]
        else:
            raise llfuse.FUSEError(errno.ENOENT)

        if not isinstance(p, Directory):
            raise llfuse.FUSEError(errno.ENOTDIR)

        fh = self._filehandles_counter
        self._filehandles_counter += 1
        if p.parent in self._inodes:
            parent = self._inodes[p.parent]
        else:
            parent = None
        self._filehandles[fh] = FileHandle(fh, [('.', p), ('..', parent)] + list(p.entries.items()))
        return fh

    def readdir(self, fh, off):
        #print "readdir: fh", fh, "off", off

        if fh in self._filehandles:
            handle = self._filehandles[fh]
        else:
            raise llfuse.FUSEError(errno.EBADF)

        #print "handle.entry", handle.entry

        e = off
        while e < len(handle.entry):
            yield (handle.entry[e][0], self.getattr(handle.entry[e][1].inode), e+1)
            e += 1

    def releasedir(self, fh):
        del self._filehandles[fh]

if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        description='Mount Keep data under the local filesystem.')
    parser.add_argument('mountpoint', type=str, help="""Mount point.""")
    parser.add_argument('--collection', type=str, required=True, help="""Collection locator""")
    parser.add_argument('--debug', action='store_true', help="""Debug mode""")

    args = parser.parse_args()

    # for testing only!
    #manifest = open('/home/peter/arvados/sdk/python/testdata/jlake_manifest').read()
    #operations = Operations(arvados.CollectionReader(manifest), os.getuid(), os.getgid())

    operations = Operations(arvados.CollectionReader(arvados.Keep.get(args.collection)), os.getuid(), os.getgid())
    
    opts = []
    if args.debug:
        opts += ['debug']

    llfuse.init(operations, args.mountpoint, opts)
    
    try:
        llfuse.main()
    except:
        llfuse.close(unmount=True)
        raise

    llfuse.close()
